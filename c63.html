<!DOCTYPE html>
<html>

<head>
    <!-- css -->
    <!--#include virtual="/styles/unity/css/css-include.html" -->
    <title>Chapter 3</title>
</head>

<body class="ncar">
    <!-- header include -->
    <!--#include virtual="/styles/unity/includes/header/header.html" -->
    <main class="container-lg py-2 pt-md-3">
        <div class="d-grid d-print-flex">
            <article class="main-content-wrapper">
                <div>
                    <table>
                        <tr>
                            <td><a href="x26.html">Prev</a></td>
                            <td><a href="index.html">Home</a></td>
                            <td><a href="x91.html">Next</a></td>
                        </tr>
                    </table>
                    <hr>
                </div>

                <div>
                    <h1 id="CPL7_Chapter2">Chapter 3. CPL7 Implementation</h1>

                    <div>
                        <b>Table of Contents</b>
                        <ul>
                            <li><a href="c63.html#implementation_time">Time Management</a></li>
                            <li><a href="x91.html">Grids</a></li>
                            <li><a href="x138.html">Initialization</a></li>
                            <li><a href="x142.html">MCT and ESMF Coupling Interfaces</a></li>
                            <li><a href="x148.html">Driver Threading Control</a></li>
                            <li><a href="x152.html">The bit-for-bit (BFB) Flag</a></li>
                            <li><a href="x156.html">History and Restart Files</a></li>
                            <li><a href="x162.html">Budget Setup and Computation</a></li>
                        </ul>
                    </div>

                    <div>
                        <h2 id="implementation_time">Time Management</h2>

                        <h3 id="implementation_time_general">Driver Clocks</h3>
                        <p>
                            The CCSM4 driver manages the main clock in the system. That clock
                            advances at the shortest coupling period and uses alarms to trigger
                            component coupling and other events. In addition, the driver maintains
                            a clock that is associated with each component. The driver's component
                            clocks have a timestep associated with <a href="c63.html#implementation_time_coupling">
                                the coupling period of that
                                component</a>. The main driver clock and the component clocks in the driver
                            advance in a coordinated manor and are always synchronized.
                            The advancement of time is managed as follows in the main run loop. First,
                            the main driver clock advances one timestep and the component clocks are
                            advanced in a synchronous fashion. The clock time represents the time
                            at the end of the next model timestep. Alarms may be triggered at that timestep
                            to call the the atmosphere, land, sea ice, land ice, or ocean run methods.
                            If a component run alarm is triggered, the run method is called and
                            the driver passes that component's clock to that component. The component clock
                            contains information about the length of the next component integration and
                            the expected time of the component at the end of the integration period.
                        </p>
                        <p>
                            Generally, the component models have indepedent time management
                            software. When a component run method is called, the component must
                            advance the proper period and also check that their internal clock is
                            consistent with the coupling clock before returning to the driver.
                            The clock passed to the component by the driver contains this information.
                            Component models are also responsible for making sure the coupling
                            period is consistent with their internal timestep. History files are
                            managed independently by each component, but restart files are
                            coordinated by the driver (see <a href="x156.html">the Section called <i>History and Restart
                                    Files</i></a>).
                        </p>
                        <p>
                            The clocks in CCSM4 are based on the ESMF clock datatype are are
                            supported in software by either an official ESMF library or by
                            software included in CCSM called esmf_wrf_timemgr. The esmf_wrf_timemgr
                            software is a much simplified Fortran implementation of a subset
                            of the ESMF time manager interfaces.
                        </p>

                        <div>
                            <h2 id="implementation_time_loop">The Driver Time Loop</h2>

                            <p>
                                The driver time loop is hardwired to
                                <a href="x26.html#design_seq">sequence the component models</a>
                                in a specific way to meet scientific requirements and to provide the maximum possible
                                concurrency of work.
                                The results of the model integration are not dependent on the processor layout of the
                                components.
                            </p>

                            <p>
                                The driver is configured to couple the atmosphere, land, and sea ice models using the
                                same coupling frequency,
                                while the ocean model may be coupled at the same or a lower frequency.
                                To support this, the driver performs temporal averaging of coupling inputs to the ocean
                                and computes the surface ocean albedo at the higher frequency.
                                No averaging is done for other component interactions; land and sea ice surface albedos
                                are calculated within their respective components.
                                Additional functionality could be added to support alternative coupling schemes, but
                                this would require careful handling of the interaction between albedo calculations and
                                atmospheric radiation.
                            </p>

                            <p>
                                The coupler processors (PEs) manage data exchange between components.
                                Tasks include deriving fields, transferring data to/from components, and executing
                                component models.
                                The time loop proceeds as follows:
                            </p>

                            <pre>
The driver clock is advanced first.
Initial data is computed on the coupler PEs.
Ocean data is rearranged to ocean PEs.
Land data is rearranged to land PEs.
Ice data is rearranged to ice PEs.
The ocean model is run.
The ice model is run.
The land model is run.
Ocean inputs are accumulated; atmosphere/ocean fluxes are computed.
Land data is sent back to the coupler.
Ice data is sent back to the coupler.
Atmospheric forcing data is computed.
Atmospheric data is rearranged to atmosphere PEs.
The atmosphere model is run.
Atmospheric data is returned to the coupler.
Ocean data is returned to the coupler.
The loop returns.
  </pre>

                            <p>
                                Within this loop, operations like mapping, merging, diagnostics, area corrections, and
                                flux computations are overlapped with component execution when possible.
                                The land ice model is not included in the above sequence as its coupling design is still
                                under development, and it will likely operate on a much longer timescale.
                            </p>

                            <p>
                                The sequencing strategy in CCSM4 has evolved over two decades to ensure conservation of
                                mass and heat, minimize lags, and maintain system stability.
                                This design aligns with concurrency limitations discussed
                                <a href="x26.html#design_seq">here</a>.
                                Land and sea ice models always run before the atmospheric model, while the coupler and
                                ocean models can run concurrently with other components.
                                The atmosphere, land, sea ice, and atmosphere/ocean flux steps are not lagged; however,
                                the ocean state is lagged by one ocean coupling period.
                                See more details <a href="x162.html">here</a>.
                            </p>

                            <p>
                                You can reduce the ocean lag by setting the namelist variable
                                <a href="x371.html#nmlv_ocean_tight_coupling">ocean_tight_coupling</a> to true.
                                This changes the step where ocean data is sent back to the coupler so it occurs earlier
                                in the loop — before the flux computation — reducing the lag by one atmosphere coupling
                                period.
                                However, it also limits the ability for the ocean and atmosphere models to run
                                concurrently.
                                This setting is most useful when the ocean coupling frequency matches the other
                                components.
                            </p>
                        </div>
                        <div>
                            <h2 id="implementation_time_coupling">Coupling Frequency</h2>

                            <p>
                                In the current implementation, the coupling period must be identical for the atmosphere,
                                sea ice, and land components.
                                The ocean coupling period may be the same or longer.
                                All coupling periods must be integer multiples of the shortest period and should evenly
                                divide a full day.
                            </p>

                            <p>
                                These coupling periods are defined in the driver namelist for each component using
                                variables such as <code>atm_cpl_dt</code> and <code>atm_cpl_offset</code>.
                                These values are specified in seconds.
                                The coupler template file calculates these values from CCSM4 script variables like
                                <code>ATM_NCPL</code>, which indicates coupling frequency per day.
                                The <code>*_cpl_dt</code> sets the duration of the coupling period in seconds, while
                                <code>*_cpl_offset</code> defines the temporal offset from the model's initial time.
                            </p>

                            <p>
                                For example, a component coupling every 6 hours (i.e., at the 6th, 12th, 18th, and 24th
                                hour) could use an offset of 3600 seconds to instead couple at the 1st, 7th, 13th, and
                                19th hour.
                                Offsets must be smaller than the period itself.
                                A positive offset shifts the alarm time forward by that many seconds.
                                Currently, offset usage is limited due to restrictions in relative coupling frequencies.
                            </p>

                            <p>
                                Offsets are important for enabling concurrency.
                                An automatic offset equal to the shortest coupling period is applied to each component's
                                coupling run alarm.
                                This subtle detail helps improve concurrency, especially when components use different
                                coupling frequencies.
                            </p>

                            <p>
                                Without this automatic offset, component run alarms would trigger only at the end of
                                their coupling periods, limiting concurrent execution.
                                To achieve better concurrency, the run alarm must be triggered as early as possible,
                                while delaying the transfer of data to the coupler until the period ends.
                            </p>

                            <p>
                                This behavior is implemented in the file <code>seq_timemgr_mod.F90</code>.
                                Its effect on ocean coupling is handled in <code>ccsm_driver.F90</code> through the
                                variables <code>ocnrun_alarm</code> and <code>ocnnext_alarm</code>.
                            </p>
                        </div>


                    </div>
                </div>

                <div>
                    <table>
                        <tr>
                            <td><a href="x26.html">Prev</a></td>
                            <td><a href="index.html">Home</a></td>
                            <td><a href="x91.html">Next</a></td>
                        </tr>
                    </table>
                </div>

            </article>
        </div>
    </main>
    <!-- footer & javascript includes -->
    <!--#include virtual="/styles/unity/includes/footer/footer.html" -->
    <!--#include virtual="/styles/unity/js/js-include.html" -->
</body>

</html>